
@article{moskewicz_chaff_nodate,
	title = {Chaff: {Engineering} an {Efficient} {SAT} {Solver}},
	url = {http://www.princeton.edu/~chaff/publication/DAC2001v56.pdf},
	abstract = {Boolean Satisfiability is probably the most studied of combinatorial optimization/search problems. Significant effort has been devoted to trying to provide practical solutions to this problem for problem instances encountered in a range of applications in Electronic Design Automation (EDA), as well as in Artificial Intelligence (AI). This study has culminated in the development of several SAT packages, both proprietary and in the public domain (e.g. GRASP, SATO) which find significant use in both research and industry. Most existing complete solvers are variants of the Davis-Putnam (DP) search algorithm. In this paper we describe the development of a new complete solver, Chaff, which achieves significant performance gains through careful engineering of all aspects of the search {\textendash} especially a particularly efficient implementation of Boolean constraint propagation (BCP) and a novel low overhead decision strategy. Chaff has been able to obtain one to two orders of magnitude performance improvement on difficult SAT benchmarks in comparison with other solvers (DP or otherwise), including GRASP and SATO.},
	language = {en},
	urldate = {2021-02-23},
	author = {Moskewicz, Matthew W and Madigan, Conor F and Zhao, Ying and Zhang, Lintao and Malik, Sharad},
	pages = {6},
	file = {Moskewicz et al. - Chaff Engineering an Efficient SAT Solver.pdf:files/7/Moskewicz et al. - Chaff Engineering an Efficient SAT Solver.pdf:application/pdf},
}

@article{schoning_sat-problem_2010,
	title = {Das {SAT}-{Problem}},
	volume = {33},
	issn = {1432-122X},
	url = {https://doi.org/10.1007/s00287-010-0459-x},
	doi = {10.1007/s00287-010-0459-x},
	number = {5},
	journal = {Informatik-Spektrum},
	author = {Sch{\"o}ning, Uwe},
	month = oct,
	year = {2010},
	pages = {479--483},
}

@inproceedings{liang_understanding_2015,
	address = {Cham},
	title = {Understanding {VSIDS} {Branching} {Heuristics} in {Conflict}-{Driven} {Clause}-{Learning} {SAT} {Solvers}},
	isbn = {978-3-319-26287-1},
	abstract = {Conflict-Driven Clause-Learning (CDCL) SAT solvers crucially depend on the Variable State Independent Decaying Sum (VSIDS) branching heuristic for their performance. Although VSIDS was proposed nearly fifteen years ago, and many other branching heuristics for SAT solving have since been proposed, VSIDS remains one of the most effective branching heuristics. Despite its widespread use and repeated attempts to understand it, this additive bumping and multiplicative decay branching heuristic has remained an enigma.},
	booktitle = {Hardware and {Software}: {Verification} and {Testing}},
	publisher = {Springer International Publishing},
	author = {Liang, Jia Hui and Ganesh, Vijay and Zulkoski, Ed and Zaman, Atulan and Czarnecki, Krzysztof},
	editor = {Piterman, Nir},
	year = {2015},
	pages = {225--241},
}

@inproceedings{cook_complexity_1971,
	title = {The complexity of theorem-proving procedures},
	booktitle = {In {Stoc}},
	publisher = {ACM},
	author = {Cook, Stephen A.},
	year = {1971},
	pages = {151--158},
	file = {Citeseer - Snapshot:files/16/summary.html:text/html;Citeseer - Full Text PDF:files/17/Cook - 1971 - The complexity of theorem-proving procedures.pdf:application/pdf},
}

@misc{lengauer_was_nodate,
	title = {Was ist funktionale {Programmierung}?},
	url = {https://www.infosun.fim.uni-passau.de/cl/lehre/funcprog05/wasistfp.html},
	urldate = {2021-06-22},
	author = {Lengauer, Christian},
	file = {Was ist funktionale Programmierung?:files/22/wasistfp.html:text/html},
}

@misc{augsten_was_nodate,
	title = {Was ist ein {Programmierparadigma}?},
	url = {https://www.dev-insider.de/was-ist-ein-programmierparadigma-a-864056/},
	abstract = {Programmierparadigmen sind verschiedene grundlegende Ans{\"a}tze und Techniken f{\"u}r die Programmierung von Software. Darunter fallen z. B. auch objektorientierte oder funktionale Programmierung.},
	language = {de},
	urldate = {2021-06-22},
	author = {Augsten, Stephan},
	file = {Snapshot:files/24/was-ist-ein-programmierparadigma-a-864056.html:text/html},
}

@incollection{nita_functional_2019,
	address = {Berkeley, CA},
	title = {Functional {Programming}},
	isbn = {978-1-4842-4507-1},
	url = {https://doi.org/10.1007/978-1-4842-4507-1_1},
	abstract = {Functional programming represents a programming paradigm in which the computations are evaluated by mathematical functions. The paradigm avoids changing states and using mutable data.},
	booktitle = {Haskell {Quick} {Syntax} {Reference}: {A} {Pocket} {Guide} to the {Language}, {APIs}, and {Library}},
	publisher = {Apress},
	author = {Nita, Stefania Loredana and Mihailescu, Marius},
	editor = {Nita, Stefania Loredana and Mihailescu, Marius},
	year = {2019},
	doi = {10.1007/978-1-4842-4507-1_1},
	pages = {1--3},
}

@book{nita_haskell_2019,
	address = {Berkeley, CA},
	title = {Haskell {Quick} {Syntax} {Reference}: {A} {Pocket} {Guide} to the {Language}, {APIs}, and {Library}},
	isbn = {978-1-4842-4506-4 978-1-4842-4507-1},
	shorttitle = {Haskell {Quick} {Syntax} {Reference}},
	url = {http://link.springer.com/10.1007/978-1-4842-4507-1},
	language = {en},
	urldate = {2021-06-24},
	publisher = {Apress},
	author = {Nita, Stefania Loredana and Mihailescu, Marius},
	year = {2019},
	doi = {10.1007/978-1-4842-4507-1},
}

@inproceedings{hudak_history_2007,
	address = {San Diego California},
	title = {A history of {Haskell}: being lazy with class},
	isbn = {978-1-59593-766-7},
	shorttitle = {A history of {Haskell}},
	url = {https://dl.acm.org/doi/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	language = {en},
	urldate = {2021-06-30},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on {History} of programming languages},
	publisher = {ACM},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	month = jun,
	year = {2007},
	pages = {3--5},
	file = {Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:files/28/Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf},
}

@misc{marlow_haskell_2021,
	title = {Haskell 2010 {Language} {Report}},
	url = {https://www.haskell.org/definition/haskell2010.pdf},
	urldate = {2021-07-01},
	author = {Marlow, Simon},
	month = jul,
	year = {2021},
	file = {haskell2010.pdf:files/36/haskell2010.pdf:application/pdf},
}

@misc{biere_kissat_nodate,
	title = {Kissat {SAT} {Solver}},
	url = {http://fmv.jku.at/kissat/},
	urldate = {2021-07-03},
	author = {Biere, Armin},
	file = {Kissat SAT Solver:files/40/kissat.html:text/html},
}

@misc{satisfiability_application_and_theory_sat_ev_sat_nodate,
	title = {{SAT} {Competitions}},
	url = {http://satcompetition.org/},
	urldate = {2021-07-03},
	author = {Satisfiability: Application {and} Theory (SAT) e.V., Hrsg:},
	file = {SAT Competitions:files/44/satcompetition.org.html:text/html},
}

@article{levin_universal_1973,
	title = {Universal {Sequential} {Search} {Problems}},
	volume = {9},
	language = {ru},
	number = {3},
	journal = {Probl. Peredachi Inf.},
	author = {Levin, L A},
	year = {1973},
	pages = {115--116},
	file = {Levin - Universal Sequential Search Problems.pdf:files/46/Levin - Universal Sequential Search Problems.pdf:application/pdf},
}

@misc{satisfiability_application_and_theory_sat_ev_sat_nodate-1,
	title = {{SAT} {Basics}},
	url = {http://satassociation.org/articles/sat.pdf},
	urldate = {2021-07-05},
	author = {Satisfiability: Application {and} Theory (SAT) e.V., Hrsg:},
	file = {sat.pdf:files/45/sat.pdf:application/pdf},
}

@misc{een_extensible_2003,
	title = {An {Extensible} {SAT}-solver},
	url = {http://minisat.se/downloads/MiniSat.pdf},
	language = {en},
	urldate = {2021-07-02},
	author = {E{\'e}n, Niklas and S"orensson, Niklas},
	year = {2003},
	file = {MiniSat.pdf:files/38/MiniSat.pdf:application/pdf},
}

@misc{sinz_sat-race_nodate,
	title = {{SAT}-{Race} 2006},
	url = {http://fmv.jku.at/sat-race-2006/results.html},
	urldate = {2021-07-06},
	author = {Sinz, Carsten},
	file = {SAT-Race 2006:files/52/results.html:text/html},
}

@incollection{biere_chapter_2021,
	title = {Chapter 18. {Bounded} {Model} {Checking}},
	isbn = {978-1-64368-160-3 978-1-64368-161-0},
	url = {http://ebooks.iospress.nl/doi/10.3233/FAIA201002},
	abstract = {One of the most important industrial applications of SAT is currently Bounded Model Checking (BMC). This technique is typically used for formal hardware verification in the context of Electronic Design Automation. But BMC has successfully been applied to many other domains as well. In practice, BMC is mainly used for falsification, which is concerned with violations of temporal properties. In addition, a considerable part of this chapter discusses complete extensions, including k-induction and interpolation. These extensions also allow to prove properties.},
	language = {en},
	urldate = {2021-07-09},
	booktitle = {Frontiers in {Artificial} {Intelligence} and {Applications}},
	publisher = {IOS Press},
	author = {Biere, Armin},
	editor = {Biere, Armin and Heule, Marijn and van Maaren, Hans and Walsh, Toby},
	month = feb,
	year = {2021},
	doi = {10.3233/FAIA201002},
	file = {FAIA185-0457.pdf:files/53/FAIA185-0457.pdf:application/pdf},
}

@article{davis_computing_1960,
	title = {A {Computing} {Procedure} for {Quantification} {Theory}},
	volume = {7},
	journal = {J. ACM},
	author = {Davis, Martin D. and Putnam, H.},
	year = {1960},
	pages = {201--215},
}

@article{davis_machine_1962,
	title = {A machine program for theorem-proving},
	volume = {5},
	journal = {Commun. ACM},
	author = {Davis, Martin D. and Logemann, G. and Loveland, D.},
	year = {1962},
	pages = {394--397},
}

@article{bloss_code_1988,
	title = {Code optimizations for lazy evaluation},
	volume = {1},
	issn = {0892-4635, 1573-0557},
	url = {http://link.springer.com/10.1007/BF01806169},
	doi = {10.1007/BF01806169},
	abstract = {Implementations of lazy evaluation for nonstrict functional languages usually involve the notion of a delayed representation of the value of an expression, which we call a thunk. We present several techniques for implementing thunks and formalize a class of optimizations that reduce both the space and time overhead of these techniques. The optimizations depend on a compile-time inferencingstrategy calledpath analysis, a generalization of strictness analysis that uncovers order-of-evaluation information. Although the techniques in this paper are focused on the compilation of a nonstrict functional language for a conventional architecture, they are directly applicable to most of the virtual machines commonly used for implementing such languages. The same techniques also apply to other forms of delayed evaluation such as futures and promises.},
	language = {en},
	number = {2},
	urldate = {2021-07-13},
	journal = {Lisp and Symbolic Computation},
	author = {Bloss, Adrienne and Hudak, Paul and Young, Jonathan},
	month = sep,
	year = {1988},
	pages = {147--164},
	file = {Bloss et al. - 1988 - Code optimizations for lazy evaluation.pdf:files/60/Bloss et al. - 1988 - Code optimizations for lazy evaluation.pdf:application/pdf},
}

@misc{nokie_side_nodate,
	title = {Side {Effects}},
	url = {https://www.radford.edu/nokie/classes/320/Tour/side.effects.html},
	urldate = {2021-07-14},
	author = {Nokie, Edward G.},
	file = {Side Effects:files/63/side.effects.html:text/html},
}
