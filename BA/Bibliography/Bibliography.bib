
@article{moskewicz_chaff_nodate,
	title = {Chaff: {Engineering} an {Efficient} {SAT} {Solver}},
	url = {http://www.princeton.edu/~chaff/publication/DAC2001v56.pdf},
	abstract = {Boolean Satisfiability is probably the most studied of combinatorial optimization/search problems. Significant effort has been devoted to trying to provide practical solutions to this problem for problem instances encountered in a range of applications in Electronic Design Automation (EDA), as well as in Artificial Intelligence (AI). This study has culminated in the development of several SAT packages, both proprietary and in the public domain (e.g. GRASP, SATO) which find significant use in both research and industry. Most existing complete solvers are variants of the Davis-Putnam (DP) search algorithm. In this paper we describe the development of a new complete solver, Chaff, which achieves significant performance gains through careful engineering of all aspects of the search {\textendash} especially a particularly efficient implementation of Boolean constraint propagation (BCP) and a novel low overhead decision strategy. Chaff has been able to obtain one to two orders of magnitude performance improvement on difficult SAT benchmarks in comparison with other solvers (DP or otherwise), including GRASP and SATO.},
	language = {en},
	urldate = {2021-02-23},
	author = {Moskewicz, Matthew W and Madigan, Conor F and Zhao, Ying and Zhang, Lintao and Malik, Sharad},
	pages = {6},
	file = {Moskewicz et al. - Chaff Engineering an Efficient SAT Solver.pdf:files/7/Moskewicz et al. - Chaff Engineering an Efficient SAT Solver.pdf:application/pdf},
}

@article{schoning_sat-problem_2010,
	title = {Das {SAT}-{Problem}},
	volume = {33},
	issn = {1432-122X},
	url = {https://doi.org/10.1007/s00287-010-0459-x},
	doi = {10.1007/s00287-010-0459-x},
	number = {5},
	journal = {Informatik-Spektrum},
	author = {Sch{\"o}ning, Uwe},
	month = oct,
	year = {2010},
	pages = {479--483},
}

@inproceedings{liang_understanding_2015,
	address = {Cham},
	title = {Understanding {VSIDS} {Branching} {Heuristics} in {Conflict}-{Driven} {Clause}-{Learning} {SAT} {Solvers}},
	isbn = {978-3-319-26287-1},
	abstract = {Conflict-Driven Clause-Learning (CDCL) SAT solvers crucially depend on the Variable State Independent Decaying Sum (VSIDS) branching heuristic for their performance. Although VSIDS was proposed nearly fifteen years ago, and many other branching heuristics for SAT solving have since been proposed, VSIDS remains one of the most effective branching heuristics. Despite its widespread use and repeated attempts to understand it, this additive bumping and multiplicative decay branching heuristic has remained an enigma.},
	booktitle = {Hardware and {Software}: {Verification} and {Testing}},
	publisher = {Springer International Publishing},
	author = {Liang, Jia Hui and Ganesh, Vijay and Zulkoski, Ed and Zaman, Atulan and Czarnecki, Krzysztof},
	editor = {Piterman, Nir},
	year = {2015},
	pages = {225--241},
}

@inproceedings{cook_complexity_1971,
	title = {The complexity of theorem-proving procedures},
	booktitle = {In {Stoc}},
	publisher = {ACM},
	author = {Cook, Stephen A.},
	year = {1971},
	pages = {151--158},
	file = {Citeseer - Snapshot:files/16/summary.html:text/html;Citeseer - Full Text PDF:files/17/Cook - 1971 - The complexity of theorem-proving procedures.pdf:application/pdf},
}

@misc{lengauer_was_nodate,
	title = {Was ist funktionale {Programmierung}?},
	url = {https://www.infosun.fim.uni-passau.de/cl/lehre/funcprog05/wasistfp.html},
	urldate = {2021-06-22},
	author = {Lengauer, Christian},
	file = {Was ist funktionale Programmierung?:files/22/wasistfp.html:text/html},
}

@misc{augsten_was_nodate,
	title = {Was ist ein {Programmierparadigma}?},
	url = {https://www.dev-insider.de/was-ist-ein-programmierparadigma-a-864056/},
	abstract = {Programmierparadigmen sind verschiedene grundlegende Ans{\"a}tze und Techniken f{\"u}r die Programmierung von Software. Darunter fallen z. B. auch objektorientierte oder funktionale Programmierung.},
	language = {de},
	urldate = {2021-06-22},
	author = {Augsten, Stephan},
	file = {Snapshot:files/24/was-ist-ein-programmierparadigma-a-864056.html:text/html},
}

@incollection{nita_functional_2019,
	address = {Berkeley, CA},
	title = {Functional {Programming}},
	isbn = {978-1-4842-4507-1},
	url = {https://doi.org/10.1007/978-1-4842-4507-1_1},
	abstract = {Functional programming represents a programming paradigm in which the computations are evaluated by mathematical functions. The paradigm avoids changing states and using mutable data.},
	booktitle = {Haskell {Quick} {Syntax} {Reference}: {A} {Pocket} {Guide} to the {Language}, {APIs}, and {Library}},
	publisher = {Apress},
	author = {Nita, Stefania Loredana and Mihailescu, Marius},
	editor = {Nita, Stefania Loredana and Mihailescu, Marius},
	year = {2019},
	doi = {10.1007/978-1-4842-4507-1_1},
	pages = {1--3},
}

@book{nita_haskell_2019,
	address = {Berkeley, CA},
	title = {Haskell {Quick} {Syntax} {Reference}: {A} {Pocket} {Guide} to the {Language}, {APIs}, and {Library}},
	isbn = {978-1-4842-4506-4 978-1-4842-4507-1},
	shorttitle = {Haskell {Quick} {Syntax} {Reference}},
	url = {http://link.springer.com/10.1007/978-1-4842-4507-1},
	language = {en},
	urldate = {2021-06-24},
	publisher = {Apress},
	author = {Nita, Stefania Loredana and Mihailescu, Marius},
	year = {2019},
	doi = {10.1007/978-1-4842-4507-1},
}

@inproceedings{hudak_history_2007,
	address = {San Diego California},
	title = {A history of {Haskell}: being lazy with class},
	isbn = {978-1-59593-766-7},
	shorttitle = {A history of {Haskell}},
	url = {https://dl.acm.org/doi/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	language = {en},
	urldate = {2021-06-30},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on {History} of programming languages},
	publisher = {ACM},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	month = jun,
	year = {2007},
	pages = {3--5},
	file = {Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:files/28/Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf},
}

@misc{marlow_haskell_2021,
	title = {Haskell 2010 {Language} {Report}},
	url = {https://www.haskell.org/definition/haskell2010.pdf},
	urldate = {2021-07-01},
	author = {Marlow, Simon},
	month = jul,
	year = {2021},
	file = {haskell2010.pdf:files/36/haskell2010.pdf:application/pdf},
}

@misc{biere_kissat_nodate,
	title = {Kissat {SAT} {Solver}},
	url = {http://fmv.jku.at/kissat/},
	urldate = {2021-07-03},
	author = {Biere, Armin},
	file = {Kissat SAT Solver:files/40/kissat.html:text/html},
}

@misc{satisfiability_application_and_theory_sat_ev_sat_nodate,
	title = {{SAT} {Competitions}},
	url = {http://satcompetition.org/},
	urldate = {2021-07-03},
	author = {Satisfiability: Application {and} Theory (SAT) e.V., Hrsg:},
	file = {SAT Competitions:files/44/satcompetition.org.html:text/html},
}

@article{levin_universal_1973,
	title = {Universal {Sequential} {Search} {Problems}},
	volume = {9},
	language = {ru},
	number = {3},
	journal = {Probl. Peredachi Inf.},
	author = {Levin, L A},
	year = {1973},
	pages = {115--116},
	file = {Levin - Universal Sequential Search Problems.pdf:files/46/Levin - Universal Sequential Search Problems.pdf:application/pdf},
}

@misc{satisfiability_application_and_theory_sat_ev_sat_nodate-1,
	title = {{SAT} {Basics}},
	url = {http://satassociation.org/articles/sat.pdf},
	urldate = {2021-07-05},
	author = {Satisfiability: Application {and} Theory (SAT) e.V., Hrsg:},
	file = {sat.pdf:files/45/sat.pdf:application/pdf},
}

@misc{een_extensible_2003,
	title = {An {Extensible} {SAT}-solver},
	url = {http://minisat.se/downloads/MiniSat.pdf},
	language = {en},
	urldate = {2021-07-02},
	author = {E{\'e}n, Niklas and S"orensson, Niklas},
	year = {2003},
	file = {MiniSat.pdf:files/38/MiniSat.pdf:application/pdf},
}

@misc{sinz_sat-race_nodate,
	title = {{SAT}-{Race} 2006},
	url = {http://fmv.jku.at/sat-race-2006/results.html},
	urldate = {2021-07-06},
	author = {Sinz, Carsten},
	file = {SAT-Race 2006:files/52/results.html:text/html},
}

@article{davis_computing_1960,
	title = {A {Computing} {Procedure} for {Quantification} {Theory}},
	volume = {7},
	journal = {J. ACM},
	author = {Davis, Martin D. and Putnam, H.},
	year = {1960},
	pages = {201--215},
}

@article{davis_machine_1962,
	title = {A machine program for theorem-proving},
	volume = {5},
	journal = {Commun. ACM},
	author = {Davis, Martin D. and Logemann, G. and Loveland, D.},
	year = {1962},
	pages = {394--397},
}

@article{bloss_code_1988,
	title = {Code optimizations for lazy evaluation},
	volume = {1},
	issn = {0892-4635, 1573-0557},
	url = {http://link.springer.com/10.1007/BF01806169},
	doi = {10.1007/BF01806169},
	abstract = {Implementations of lazy evaluation for nonstrict functional languages usually involve the notion of a delayed representation of the value of an expression, which we call a thunk. We present several techniques for implementing thunks and formalize a class of optimizations that reduce both the space and time overhead of these techniques. The optimizations depend on a compile-time inferencingstrategy calledpath analysis, a generalization of strictness analysis that uncovers order-of-evaluation information. Although the techniques in this paper are focused on the compilation of a nonstrict functional language for a conventional architecture, they are directly applicable to most of the virtual machines commonly used for implementing such languages. The same techniques also apply to other forms of delayed evaluation such as futures and promises.},
	language = {en},
	number = {2},
	urldate = {2021-07-13},
	journal = {Lisp and Symbolic Computation},
	author = {Bloss, Adrienne and Hudak, Paul and Young, Jonathan},
	month = sep,
	year = {1988},
	pages = {147--164},
	file = {Bloss et al. - 1988 - Code optimizations for lazy evaluation.pdf:files/60/Bloss et al. - 1988 - Code optimizations for lazy evaluation.pdf:application/pdf},
}

@misc{nokie_side_nodate,
	title = {Side {Effects}},
	url = {https://www.radford.edu/nokie/classes/320/Tour/side.effects.html},
	urldate = {2021-07-14},
	author = {Nokie, Edward G.},
	file = {Side Effects:files/63/side.effects.html:text/html},
}

@article{marques-silva_grasp_1999,
	title = {{GRASP}: a search algorithm for propositional satisfiability},
	volume = {48},
	issn = {00189340},
	shorttitle = {{GRASP}},
	url = {http://ieeexplore.ieee.org/document/769433/},
	doi = {10.1109/12.769433},
	abstract = {{\DH}This paper introduces GRASP (Generic seaRch Algorithm for the Satisfiability Problem), a new search algorithm for Propositional Satisfiability (SAT). GRASP incorporates several search-pruning techniques that proved to be quite powerful on a wide variety of SAT problems. Some of these techniques are specific to SAT, whereas others are similar in spirit to approaches in other fields of Artificial Intelligence. GRASP is premised on the inevitability of conflicts during the search and its most distinguishing feature is the augmentation of basic backtracking search with a powerful conflict analysis procedure. Analyzing conflicts to determine their causes enables GRASP to backtrack nonchronologically to earlier levels in the search tree, potentially pruning large portions of the search space. In addition, by {\textordfeminine}recording{\textordmasculine} the causes of conflicts, GRASP can recognize and preempt the occurrence of similar conflicts later on in the search. Finally, straightforward bookkeeping of the causality chains leading up to conflicts allows GRASP to identify assignments that are necessary for a solution to be found. Experimental results obtained from a large number of benchmarks indicate that application of the proposed conflict analysis techniques to SAT algorithms can be extremely effective for a large number of representative classes of SAT instances.},
	language = {en},
	number = {5},
	urldate = {2021-07-16},
	journal = {IEEE Transactions on Computers},
	author = {Marques-Silva, J.P. and Sakallah, K.A.},
	month = may,
	year = {1999},
	pages = {506--521},
	file = {Marques-Silva und Sakallah - 1999 - GRASP a search algorithm for propositional satisf.pdf:files/64/Marques-Silva und Sakallah - 1999 - GRASP a search algorithm for propositional satisf.pdf:application/pdf},
}

@inproceedings{marques_graspnew_1996,
	title = {{GRASP}{\textemdash}{A} {New} {Search} {Algorithm} for {Satisfiability}},
	abstract = {This report introduces GRASP (Generic seaRch Algorithm for the Satisfiability Problem), an integrated algorithmic framework for SAT that unifies several previously proposed search-pruning techniques and facilitates identification of additional ones. GRASP is premised on the inevitability of conflicts during search and its most distinguishing feature is the augmentation of basic backtracking search with a powerful conflict analysis procedure. Analyzing conflicts to determine their causes enables GRASP to backtrack non-chronologically to earlier levels in the search tree, potentially pruning large portions of the search space. In addition, by "recording" the causes of conflicts, GRASP can recognize and preempt the occurrence of similar conflicts later on in the search. Finally, straightforward bookkeeping of the causality chains leading up to conflicts allows GRASP to identify assignments that are necessary for a solution to be found. Experimental results obtained from a large number of ...},
	booktitle = {in {Proceedings} of the {International} {Conference} on {Computer}-{Aided} {Design}},
	author = {Marques, Jo and Silva, Jo??o P. Marques and Silva, Jo??o P. Marques and Sakallah, Karem A. and Sakallah, Karem A.},
	year = {1996},
	pages = {220--227},
	file = {Citeseer - Full Text PDF:files/67/Marques et al. - 1996 - GRASP{\textemdash}A New Search Algorithm for Satisfiability.pdf:application/pdf;Citeseer - Snapshot:files/68/download.html:text/html},
}

@article{jr_using_nodate,
	title = {Using {CSP} {Look}-{Back} {Techniques} to {Solve} {Real}-{World} {SAT} {Instances}},
	abstract = {We report on the performance of an enhanced version of the {\textquotedblleft}Davis-Putnam{\textquotedblright} (DP) proof procedure for propositional satisfiability (SAT) on large instances derived from realworld problems in planning, scheduling, and circuit diagnosis and synthesis. Our results show that incorporating CSP lookback techniques -- especially the relatively new technique of relevance-bounded learning -- renders easy many problems which otherwise are beyond DP{\textquoteright}s reach. Frequently they make DP, a systematic algorithm, perform as well or better than stochastic SAT algorithms such as GSAT or WSAT. We recommend that such techniques be included as options in implementations of DP, just as they are in systematic algorithms for the more general constraint satisfaction problem.},
	language = {en},
	author = {Jr, Roberto J Bayardo and Schrag, Robert C},
	pages = {6},
	file = {Jr und Schrag - Using CSP Look-Back Techniques to Solve Real-World.pdf:files/69/Jr und Schrag - Using CSP Look-Back Techniques to Solve Real-World.pdf:application/pdf},
}

@incollection{kroening_decision_2016,
	address = {Berlin, Heidelberg},
	title = {Decision {Procedures} for {Propositional} {Logic}},
	isbn = {978-3-662-50497-0},
	url = {https://doi.org/10.1007/978-3-662-50497-0_2},
	abstract = {This chapter introduces decision procedures for propositional logic.},
	booktitle = {Decision {Procedures}: {An} {Algorithmic} {Point} of {View}},
	publisher = {Springer Berlin Heidelberg},
	author = {Kroening, Daniel and Strichman, Ofer},
	year = {2016},
	doi = {10.1007/978-3-662-50497-0_2},
	pages = {27--58},
}
