#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\master Thesis_CDCL_SAT_Solver.lyx
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type authoryear
\biblatex_bibstyle numeric
\biblatex_citestyle numeric
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Algorithmen
\end_layout

\begin_layout Paragraph
In diesem Kapitel wird der DPLL-Algorithmus und CDCL-Algorithmus vorgestellt.
 Anhand einer Literaturarbeit werden die Erweiterung erläutert, die das
 CDCL-Verfahren performanter im Gegensatz zu DPLL machen.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Die in der Arbeit vorgestellten Algorithmen sind bewährte Methoden, um SAT-Probl
eme zu lösen.
 Die Regeln des DPLL-Algorithmus wurden sinngemäß aus den Publikation von
 Davis, Putnam, Logemann und Loveland übernohmen 
\begin_inset CommandInset citation
LatexCommand citeyear
key "davis_computing_1960,davis_machine_1962"
literal "false"

\end_inset

.
 Die Definitionen, die im Kapitel 4.2 vorkommen, wurden sinngemäß aus dem
 Buch von Kroening und Strichman 
\begin_inset CommandInset citation
LatexCommand citeyear
key "kroening_decision_2016"
literal "false"

\end_inset

 übernommen.
\end_layout

\begin_layout Section
DPLL-Algorithmus 
\begin_inset CommandInset label
LatexCommand label
name "sec:DPLL-Algorithmus"

\end_inset


\end_layout

\begin_layout Standard
Martin Davis und Hilary Putnam entwickelten 1960 den Davis-Putnam-Algorithmus
 (DP) 
\begin_inset CommandInset citation
LatexCommand citeyear
key "davis_computing_1960"
literal "false"

\end_inset

, der als Basis für das 1962 entwickelte DPLL-Verfahren verwendet wird.
 Der Algorithmus wurde von Martin Davis, George Logemann und Donald Loveland
 präsentiert und besitzt drei Regeln 
\begin_inset CommandInset citation
LatexCommand citeyear
key "davis_machine_1962"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Die erste Regel ist die Eliminierung von Klauseln mit nur einem Literal
 
\begin_inset CommandInset citation
LatexCommand citeyear
key "davis_computing_1960"
literal "false"

\end_inset

.
 Mit dieser Regel wurden vier Teilregeln eingeführt.
 Diese sind folgende:
\end_layout

\begin_layout Enumerate
Existieren zwei atomare Klauseln mit gegenteiligen Literalen, wie z.B.
 
\begin_inset Formula $\{p\}$
\end_inset

 und
\begin_inset Formula $\{\neg p\}$
\end_inset

, so ist die Formel F UNSAT.
\end_layout

\begin_layout Enumerate
Existiert eine atomare Klausel mit nur einem positiven Literal p, so können
 alle Klauseln, die ein 
\begin_inset Formula $p$
\end_inset

 beinhalten, gelöscht werden.
 Negierte 
\begin_inset Formula $p$
\end_inset

's werden dahingegen aus allen Klauseln gelöscht.
 
\begin_inset CommandInset label
LatexCommand label
name "enu:Teilregel_1"

\end_inset


\end_layout

\begin_layout Enumerate
Die dritte Teilregel ist wie die zweite Teilregel, jedoch mit umgekehrten
 Vorzeichen.
 
\end_layout

\begin_layout Enumerate
Die Formel ist SAT, wenn F nach anwenden der Regeln leer wird.
\end_layout

\begin_layout Standard
Die zweite Regel ist die 
\begin_inset Quotes gld
\end_inset

Affirmative-Negative Rule
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citeyear
key "davis_computing_1960"
literal "false"

\end_inset

.
 Diese Regel ist ähnlich zur Regel 1.2 und 1.3.
 Anstelle von atomaren Klauseln wird hier eine Entscheidung für ein Literal
 in einer Klausel getroffen.
 Wenn das Literal 
\begin_inset Formula $p$
\end_inset

 mit 
\begin_inset Formula $\top$
\end_inset

 belegt wird, so werden alle Klauseln mit einem positiven 
\begin_inset Formula $p$
\end_inset

 gelöscht, während alle negierten 
\begin_inset Formula $p$
\end_inset

's aus den Klauseln gelöscht werden.
 Dies geschieht auch umgekehrt mit einer Literalbelegung von 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Standard
Als dritte Regel wurde die Teilungs Regel vorgestellt 
\begin_inset CommandInset citation
LatexCommand citeyear
key "davis_machine_1962"
literal "false"

\end_inset

.
 In dieser Regel wird eine Formel 
\begin_inset Formula $F$
\end_inset

 in die Form 
\begin_inset Formula $(A\vee p)\wedge(B\vee-p)\wedge R$
\end_inset

 aufgeteilt, wobei 
\begin_inset Formula $p$
\end_inset

 nicht in 
\begin_inset Formula $A,B$
\end_inset

 und 
\begin_inset Formula $R$
\end_inset

 vorhanden ist.
 
\begin_inset Formula $A$
\end_inset

 und 
\begin_inset Formula $B$
\end_inset

 stellen hierbei eine Menge von anderen Literale dar, während 
\begin_inset Formula $R$
\end_inset

 eine Menge von anderen Klauseln in 
\begin_inset Formula $F$
\end_inset

 darstellet.
 
\begin_inset Formula $F$
\end_inset

 wird UNSAT, wenn für die Belegungen 
\begin_inset Formula $p=\bot$
\end_inset

 und 
\begin_inset Formula $A\wedge R$
\end_inset

 und 
\begin_inset Formula $p=\top$
\end_inset

 und 
\begin_inset Formula $B\wedge R$
\end_inset

 die Klauseln in der Formel inkonsistenz aufzeigen.
\end_layout

\begin_layout Standard
Ein Beispiel wie die Regeln 1 und 2 funktionieren, wird an folgendem Problem
 gezeigt:
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\begin{equation}
F=x_{1}\wedge(\neg x_{1}\vee\neg x_{2})\wedge(x_{1}\vee x_{2})\wedge(x_{3}\vee x_{4})\wedge(x_{4}\vee x_{5})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\[
Setze\,x_{1}\equiv\top
\]

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\begin{equation}
\Leftrightarrow\neg x_{2}\wedge(x_{3}\vee x_{4})\wedge(x_{4}\vee x_{5})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\[
Setze\,x_{2}\equiv\bot
\]

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\begin{equation}
\Leftrightarrow(x_{3}\vee x_{4})\wedge(x_{4}\vee x_{5})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\[
Setze\,x_{4}\equiv\top
\]

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Formula 
\begin{equation}
\Rightarrow SAT
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die zweite Teilregel der ersten Regel wird im ersten Schritt angewendet.
 Diese löscht alle Klauseln, die eine positive 
\begin_inset Formula $x_{1}$
\end_inset

 besitzen, und alle negierten 
\begin_inset Formula $x_{1}$
\end_inset

 aus allen Klauseln.
 Dadurch kommt die Formel 
\begin_inset Formula $x_{2}\wedge(x_{3}\vee x_{4})\wedge(x_{4}\vee x_{5})$
\end_inset

 im zweiten Schritt zustande.
 Nach der Anwendung der dritten Teilregel für das Literal 
\begin_inset Formula $x_{2}$
\end_inset

 kommt die Formel 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(3\vee4)\wedge(4\vee5)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 als Ergebnis heraus.
 Mit dem Einsetzen von 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $4=T$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 wird die zweite Regel benutzt, wodurch die leere Menge entsteht.
 Dadurch wird die gesamte Formel mit SAT evaluiert.
\end_layout

\begin_layout Standard
Wenn die Formel F jedoch noch eine atomare Klausel 
\begin_inset Formula $(\neg x_{1})$
\end_inset

 besitzen würde, würde die Formel F als UNSAT evaluiert werden, da die erste
 Teilregel von Regel 1 bei zwei atomaren Klauseln mit unterschiedlichen
 Vorzeichen und gleichen Literalen die Formel als UNSAT beurteilt.
\end_layout

\begin_layout Section
CDCL-Algorithmus
\end_layout

\begin_layout Standard
CDCL SAT-Solver basieren auf den DPLL-Algorithmus und verwenden zusätzlich
 zu den Regeln mehrere Optimierungen und einen Algorithmus, die dem CDCL
 seinem Namen verdankt.
 CDCL wurde in Publikationen von Marques-Silva und Sakallah 1996 
\begin_inset CommandInset citation
LatexCommand citeyear
key "marques_graspnew_1996"
literal "false"

\end_inset

 und 1999 
\begin_inset CommandInset citation
LatexCommand citeyear
key "marques-silva_grasp_1999"
literal "false"

\end_inset

 und Bayardo und Schrag 1997 
\begin_inset CommandInset citation
LatexCommand citeyear
key "jr_using_nodate"
literal "false"

\end_inset

 vorgeschlagen.
 Der CDCL-Algorithmus wird immer dann angewendet, wenn nach der Anwendung
 des Entscheidungsalgorithmus (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Entscheidungsalgorithmus"
plural "false"
caps "false"
noprefix "false"

\end_inset

) und Boolean Constraint Propagation (BCP, siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Unitpropagation"
plural "false"
caps "false"
noprefix "false"

\end_inset

) ein Konflikt auftritt.
 Ein Konflikt ensteht, wenn eine Zuweisung von Literalen bei einer Klausel
 keine logische wahre Aussage ergibt.
 Das folgendes Beispiel soll diesen Fall zeigen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
F=(\neg x_{1}\vee\neg x_{2})\wedge(\neg x_{1}\vee x_{2})\wedge(x_{1}\vee x_{2})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Setze\,x_{1}\equiv\top\,(Entscheidung)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\Leftrightarrow\neg x_{2}\wedge x_{2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Setze\,x_{2}\equiv\bot
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow Konflikt\,bei\,Klausel\,(\neg x_{1}\vee x_{2})
\]

\end_inset


\end_layout

\begin_layout Standard
Die Klausel 
\begin_inset Formula $(\neg x_{1}\vee x_{2})$
\end_inset

 hat einen Konflikt für die Belegungen 
\begin_inset Formula $1=\top$
\end_inset

 und 
\begin_inset Formula $2=\bot$
\end_inset

 verursacht.
 In der Publikation von Marques-Silva und Sakallah 
\begin_inset CommandInset citation
LatexCommand citeyear
key "marques-silva_grasp_1999"
literal "false"

\end_inset

 wird die Verwendung eines Implikationsgraphen vorgeschlagen, um diesen
 Konflikt zu lösen.
 Ein Implikationsgraph ist ein gerichteter, azyklischer Graph, der alle
 derzeitigen Literalbelegungen eines SAT-Problemes darstellt.
 Hierfür stellen die Wurzelknoten des Graphen die Entscheidungen dar, während
 andere Knoten Literalbelegungen durch Unitpropagation (
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Unitpropagation"
plural "false"
caps "false"
noprefix "false"

\end_inset

) abbilden.
 Die Kanten stellen Klauseln dar, die zur Belegung von Literalen geführt
 haben.
 Des Weiteren geben die Knoten auch Informationen dar, zu welchem Entscheidungsl
evel (Level) ein Literal belegt wurde oder ob ein Konflikt durch die Belegung
 enstanden ist.
 Beim Start des CDCL-Algorithmus fängt das Level mit dem Integer 0 an und
 steigt immer um 1, wenn eine Entscheidung gefällt werden muss.
 Konflikte werden im Graphen, wie die Belegungen, als Knoten dargestellt.
 Sollte ein Konfliktknoten im Level 0 auftreten, so ist das SAT-Problem
 UNSAT.
\end_layout

\begin_layout Standard
Für das Beispiel in Formel 4.5 würde der Graph folgendermaßen aussehen:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abbildungen/example.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
captionof{figure}{Beispiel eines Implikationsgraphen}{Die Plusse stellen
 
\backslash
begin{math} 
\backslash
vee 
\backslash
end{math} dar.
 Das F steht in dieser Abbildung f
\backslash

\begin_inset Quotes grd
\end_inset

ur 
\backslash
botV} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Graph in Abbildung 4.1 ist gleichzeitig auch ein partieller Implikationsgraph
, da dieser alle relevanten Entscheidungen und Literalbelegungen zum Konflikt
 im zurzeitigen Level zeigt.
 Um die Konfliktklausel zu lernen wird Resolution 
\begin_inset CommandInset citation
LatexCommand citeyear
key "kroening_decision_2016"
literal "false"

\end_inset

 verwendet.
 
\end_layout

\begin_layout Standard
Hierbei ist die Resolution folgende Regel:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\frac{x_{1}\vee x_{...}\vee x_{n}\vee p\,\,\,\,\,\,\,\,\,\,\,y_{1}\vee y_{...}\vee y_{n}\vee-p}{x_{1}\vee x_{...}\vee x_{n}\vee y_{1}\vee y_{...}\vee y_{n}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Resolution benötigt mindestens zwei Klauseln, die ein polarisierendes
 Literal beinhalten.
 In der Formel 4.7 wird dies durch die zwei Klauseln im Zähler dargestellt.
 Durch die Anwendung der Regel wird das ausgewählte polarisierende Literale
 aus den Klauseln gelöscht und die Klauseln werden zu der Klausel im Nenner
 vereinigt.
 Die Klauseln im Zähler werden auch resolving clauses (RC) genannt.
 Das Literal 
\begin_inset Formula $p$
\end_inset

 ist hierbei eine resolution variable, die nach der Resolution ihre Literalbeleg
ung verliert.
 Die resultierede Klausel im Nenner wird als resolvent clause bezeichnet
 und kann als Klausel für die nächste Resolution verwendet werden oder zur
 Formel als gelernte Konfliktklausel hinzugefügt werden.
 Die Resolution kann nicht mehr angewendet werden, wenn keine Klauseln mehr
 existierenden, die jeweils ein Literal 
\begin_inset Formula $p$
\end_inset

 mit polarisierenden Vorzeichen besitzen.
\end_layout

\begin_layout Standard
Die Resolutionschritte gehen einen Implikationsgraphen, der von links nach
 rechts entwickelt wird, von rechts nach links ab.
 Dabei gibt es verschiedene Stopkriterien, die verwendet werden können,
 um die Konfliktklausel zu lernen.
 In dieser Arbeit wird 
\begin_inset Quotes gld
\end_inset

First Unique Implication Point
\begin_inset Quotes grd
\end_inset

 (1UIP) 
\begin_inset CommandInset citation
LatexCommand citeyear
key "kroening_decision_2016"
literal "false"

\end_inset

 als Stopkriterium für die Konfliktanalyse verwendet.
 1UIP ist ein 
\begin_inset Quotes gld
\end_inset

Unique Implication Point
\begin_inset Quotes grd
\end_inset

 (UIP), der dem Konfliktknoten am nähesten ist.
 Dies liegt daran, dass die Entscheidung an diesem Knotenpunkt einen Konflikt
 augelöst hat.
 Solange die Konfliktklausel nach dem 
\begin_inset Quotes gld
\end_inset

Backjumping
\begin_inset Quotes grd
\end_inset

 nur ein unbelegtes Literal besitzen, können die SAT-Solver in diesem Prozess
 bis zum zweithöchsten Entscheidungslevel zurückspringen.
 Dadurch werden alle Literalbelegungen vom höchsten bis zum zweithöchsten
 + 1 gefundenen Level gelöscht.
 Dieser Prozess wird auch Backjumping genannt, da hierbei über mehrere Level
 zurückgesprungen werden kann, während beim Backtracking immer nur ein Level
 zurückgesprungen wird.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abbildungen/ResolutionExample.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
captionof{figure}{Resolution}{Die Grafik illustriert den Ablauf der Resolution
 für das Beispiel in der Abbildung 4.1}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Abbildung 4.2 werden die Klauseln 
\begin_inset Formula $c_{1}$
\end_inset

 und 
\begin_inset Formula $c_{2}$
\end_inset

 für die Resolution verwendet, da die Klausel 
\begin_inset Formula $c_{2}$
\end_inset

 den Konflikt verursacht hat und die Klausel 
\begin_inset Formula $c_{1}$
\end_inset

 für die Belegung der Variable 
\begin_inset Formula $x_{2}$
\end_inset

 verantwortlicht ist.
 Als Ergebnis kommt die neue Klausel 
\begin_inset Formula $(\neg x_{1})$
\end_inset

 heraus und wird zur Formel 4.5 hinzugefügt.
 Gleichzeitig werden alle Belegungen, die auf dem Entscheidungslevel 1 getroffen
 wurden, gelöscht und das Level wird auf 0 zurückgesetzt.
 Danach wird der BCP-Prozess fortgeführt und eine Lösung mit den Belegungen
 
\begin_inset Formula $x_{1}\equiv\bot@0$
\end_inset

 und 
\begin_inset Formula $x_{2}\equiv\top@0$
\end_inset

 wird gefunden.
\end_layout

\begin_layout Section
Unterschied zwischen DPLL und CDCL (not done)
\end_layout

\begin_layout Standard
Der Unterschied zwischen DPLL und CDCL ist das Konzept des Backjumpings
 und das Lernen von Konfliktklauseln.
 Während der DPLL-Algorithmus durch Backtracking Konflikte löst, verwendet
 CDCL diese Konzepte, um schnellere Ergebnisse zu einem SAT-Problem zu finden.
 Backjumping führt potentiell zu schnelleren Ergebnissen, da beim Backtracking
 folgendes Problem auftreten kann:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abbildungen/DPLL_example.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
captionof{figure}{DPLL 1}{Der DPLL Algorithmus.
 Für die Entscheidungen wurden die Literale immer auf 
\backslash
botV gesetzt.
 Die Belegung von 
\backslash
begin{math} x_1 
\backslash
end{math} ist egal, da diese zu jeder Belegung einen Konflikt auslöst.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abbildungen/DPLL_example2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
captionof{figure}{DPLL 2}{Der DPLL-Algorithmus hat das Literal 
\backslash
begin{math} x_3 
\backslash
equiv 
\backslash
top 
\backslash
end{math} gesetzt.
 Dies ändert jedoch nichts für die Belegung von 
\backslash
begin{math} x_4 
\backslash
end{math}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abbildungen/DPLL_example3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
captionof{figure}{DPLL 3}{Der DPLL-Algorithmus ist zum Level 2 zurückgegangen
 und hat das Literal 
\backslash
begin{math} x_2 
\backslash
equiv 
\backslash
top 
\backslash
end{math} und 
\backslash
begin{math} x_3 
\backslash
equiv 
\backslash
bot 
\backslash
end{math} gesetzt.
 Dies ändert jedoch nichts für die Belegung von 
\backslash
begin{math} x_4 
\backslash
end{math} In den darauffolgendenen Schritten würde der Algorithmus 
\backslash
begin{math} x_3 
\backslash
equiv 
\backslash
top 
\backslash
end{math} setzen und wieder einen Konflikt herbeiführen.
 Danach würde der Algorithmus nach mehrmaligen Backtracking eine Lösung
 mit 
\backslash
begin{math} x_1 
\backslash
equiv 
\backslash
top, x_2 
\backslash
equiv 
\backslash
top, x_3 
\backslash
equiv 
\backslash
top und x_4 
\backslash
equiv 
\backslash
top 
\backslash
end{math} finden}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
